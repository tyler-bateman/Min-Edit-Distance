My solution for displaying the alignment uses the method in which a backtrace is stored during the calculation, as opposed to the method that traces back by looking for the minimum value at each step. I accomplished this by having the distance() method return a tuple containing the distance and the backtrace array instead of just the distance. I then used a separate method, generate_alignment() to generate the alignment. generate_alignment() returns a tuple containing three strings: the formatted version of the target word, the string containing the '|' characters to show which letters did not change, and the formatted version of the source word. In the backtrace array, the pointers for moving left, down, or diagonal were enumerated by constants defined in bt_constants.py. To generate the most concise alignment, I decided to give preference to substitutions over insertions and deletions because I think a substitution looks nicer than an insertion followed by a deletion.
